# -*- coding: utf-8 -*-
"""Base de Dados - Ecommerce MK

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WMRddcXrWZgG7dHqzBtgFg58sBw8zhb8
"""

!pip install faker
import pandas as pd
import numpy as np
from faker import Faker
import random

fake = Faker(['pt_BR'])
Faker.seed(42)

# Configurações de volume
num_users = 10000
num_products = 5000   #Descrição detalhada dos produtos
num_orders = 35000    #Descrição dos recibos de compra
num_items = 60000     #Descrição dos itens nos pedidos


print("Iniciando geração de base de dados completa...")

# 1. PRODUTOS (Essencial para o Item 5 - GenAI)
product_templates = {
    'Eletrônicos': {
        'items': ['Smartphone', 'Smartwatch', 'Notebook', 'Tablet', 'Fone de Ouvido Bluetooth'],
        'marcas': ['Apple', 'Samsung', 'LG', 'Motorola'],
        'materiais': ['Alumínio aeroespacial', 'Vidro temperado', 'Polímero de alta resistência'],
        'specs': ['Bateria de 5000mAh', 'Processador Octa-core', 'Tela Super AMOLED', 'Conexão 5G']
    },
    'Casa': {
        'items': ['Cafeteira Expressa', 'Aspirador de Pó Robô', 'Luminária Inteligente', 'Fritadeira Elétrica'],
        'marcas': ['Dyson', 'ConfortPlus', 'Eletrolux'],
        'materiais': ['Aço inoxidável', 'Plástico BPA Free', 'Revestimento cerâmico'],
        'specs': ['Potência de 1500W', 'Controle via App', 'Economia de energia A+++', 'Design ergonômico']
    },
    'Moda': {
        'items': ['Tênis de Corrida', 'Mochila Impermeável', 'Relógio Analógico', 'Jaqueta Corta-vento'],
        'marcas': ['North Face', 'Adidas', 'Nike'],
        'materiais': ['Tecido respirável', 'Couro sintético Premium', 'Fibras recicladas'],
        'specs': ['Costura reforçada', 'Tecnologia Dry-fit', 'Zíper selado', 'Leve e resistente']
    }
}

products_data = []
product_id_counter = 1
versoes = ['Basic', 'Plus', 'Premium', 'Pro Max']

for cat, info in product_templates.items():
    for item in info['items']: # Ex: Smartphone
        for marca in info['marcas']: # Ex: Apple
            material_base = random.choice(info['materiais'])
            price_seed = random.uniform(150, 500)

            for idx, versao in enumerate(versoes):
                title = f"{item} {marca} - {versao}"
                spec_v = random.choice(info['specs'])

                # Preço escala conforme a versão e categoria
                multiplier = 1.0 + (idx * 0.5)
                final_price = round(price_seed * multiplier, 2)

                description = (
                    f"O {title} é a escolha ideal para quem busca performance. "
                    f"Fabricado com {material_base}, este modelo {versao} oferece {spec_v}. "
                    f"Produto original {marca} com acabamento premium."
                )

                products_data.append({
                    'product_id': product_id_counter,
                    'title': title,
                    'description': description,
                    'category': cat,
                    'item_type': item,
                    'brand': marca,
                    'model_tier': versao,
                    'price': final_price
                })
                product_id_counter += 1

df_products = pd.DataFrame(products_data)
num_products = len(df_products)

#--- 2. CLIENTES (Baseado no seu models.py: User) ---
users_data = []
for i in range(1, num_users + 1):
    first_name = fake.first_name()
    last_name = fake.last_name()
    # Remove espaços e acentos para criar um e-mail válido
    user_handle = f"{first_name.lower()}{last_name.lower()}".replace(" ", "")
    email_domain = fake.free_email_domain()

    users_data.append({
        'user_id': i,
        'email': f"{user_handle}@{email_domain}",
        'name': first_name,
        'last_name': last_name,
        'country': 'Brasil',
        'is_premium': random.choice([True, False]),
        'created_at': fake.date_time_between(start_date='-2y', end_date='now')
    })
df_users = pd.DataFrame(users_data)

# --- 3. PEDIDOS (Baseado no seu models.py: Receipt) ---
orders_data = []
items_data = []
item_id_counter = 1

for i in range(1, num_orders + 1):
    order_date = fake.date_time_between(start_date='-2y', end_date='now')
    order_status = random.choice(['delivered', 'shipped', 'processing'])
    shipping_val = round(random.uniform(0, 50), 2)

    orders_data.append({
        'order_id': i,
        'user_id': random.randint(1, num_users),
        'order_date': order_date,
        'status': order_status,
        'payment_method': random.choice(['Credit Card', 'Boleto', 'Pix']),
        'shipping_cost': shipping_val,
        'total_amount': 0 # Será atualizado abaixo
    })

    # Lógica de múltiplos produtos por pedido (1 a 5 produtos diferentes)
    n_items_in_order = random.randint(1, 5)
    selected_prods = random.sample(range(0, num_products), n_items_in_order)

    # Somamos apenas o valor dos produtos nesta variável
    items_sum = 0
    for prod_idx in selected_prods:
        prod = df_products.iloc[prod_idx]
        qty = random.randint(1, 3) # Permitindo mais de 1 unidade por item para ser real
        subtotal = prod['price'] * qty
        items_sum += subtotal

        items_data.append({
            'item_id': item_id_counter,
            'order_id': i,
            'product_id': prod['product_id'],
            'product_name': prod['title'],
            'quantity': qty,
            'unit_price': prod['price'],
            'subtotal': round(subtotal, 2)
        })
        item_id_counter += 1

    # CÁLCULO FINAL: Soma dos produtos + o valor fixo do frete do pedido
    orders_data[-1]['total_amount'] = round(items_sum + shipping_val, 2)

# Transformando em DataFrame após o loop
df_orders = pd.DataFrame(orders_data)
df_items = pd.DataFrame(items_data)


# --- EXPORTAÇÃO FINAL ---
df_products.to_csv('ecommerce_products.csv', index=False)
df_users.to_csv('ecommerce_users.csv', index=False)
df_orders.to_csv('ecommerce_orders.csv', index=False)
df_items.to_csv('ecommerce_items.csv', index=False)

total_regs = len(df_products) + len(df_users) + len(df_orders) + len(df_items)
print(f"Sucesso! {total_regs} registros gerados.")